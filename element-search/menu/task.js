const LINK = document.getElementsByClassName('menu__link');


// Найдите все подменю, которые должны открываться и закрываться.
const MENU_SUB = document.querySelectorAll(".menu_sub") 

// Перебирайте найденые подменю и у каждого подменю находите рядом ссылки ((1)с помощью closest найдите внешний элемент списка и (2) внутри элемента списка найдите ссылку).
const MENU_SUB_LINK = Array.from(MENU_SUB).forEach(element => element.closest(".menu__item"));

// const D = MENU_SUB[0].closest(".menu__item")

const A =  document.querySelectorAll(".menu_sub .menu__link"); // Для полученных ссылок, при переборе добавляйте обработчик события…То есть обработчик события будет добавлен только для ссылок у которых есть подменю.

Array.from(MENU_SUB).forEach(element => element.onclick = (element) => { // 1. обработчик события click на на элементах с классом *menu__link*
    
    
    
    
    element.classList.toggle("menu_active")

    // return false
    // e.preventDefault();
})

Array.from(A).forEach(element => element.onclick = (e) => {
    return false
})




// Внутри обработчика события клика по подменю у вас должна быть ссылка (по которой произошёл клик) и подменю (которое находится рядом).
// Попробуйте найти уже открытое подменю в навигаторе (с помощью селектора).
// Если открытое подменю существует, то его необходимо закрыть.
// Далее, необходимо проверить: а какое подменю вы закрыли? Является ли это подменю тем же самым, что и то, которое находится рядом со ссылкой (у которой было событие (из шагов 1 и 4)).
// Если это разные элементы, то необходимо открыть подменю, возле которого был клик (из шагов 1 и 4)
// И последним вариантом остаётся то, что открытое ранее подменю (из 5 шага) совпадает с подменю возле ссылки (из шагов 1 и 4)…В таком случае, следовало просто закрывать ранее открытое подменю, что и должно было выполниться на 6-ом шаге…Вам останется только вернуть false, чтобы не срабатывало обновление страницы.